#!/usr/bin/env perl
#===============================================================================
#
#         FILE: status.pl
#
#        USAGE: ./status.pl
#
#  DESCRIPTION: 
#
#      OPTIONS: ---
#       AUTHOR: Tuomas Poikela (tpoikela), tuomas.sakari.poikela@gmail.com
# ORGANIZATION: ----
#      VERSION: 0.1
#      CREATED: 01/11/2020 09:23:56 AM
#===============================================================================

use strict;
use warnings;
use utf8;

use Getopt::Long;
use Pod::Usage;


package Parser;

sub new {
    my $proto = shift;
    my $class = ref($proto) || $proto;

    my $self = {
        curr_class => undef,
        curr_func => undef,
        lang => undef,
        re => {}
    };
    bless($self, $class);

    $self->_init_re();
    return $self;
}

sub parse_line {
    my ($self, $line) = @_;

}

sub func_start {
    my ($self, $line) = @_;
}

sub func_end {
    my ($self, $line) = @_;
}

sub class_start {
    my ($self, $line) = @_;
}

sub class_end {
    my ($self, $line) = @_;
}

sub _init_re {
    my ($self) = @_;

    my $re_qual = qr/(extern|virtual|protected|local|static)*/;
    my $ret_val = qr/(.*)/;

    $self->{re}->{sv} = {
        # Format is regex to match, flags, captures
        func_start => [
            qr/^$re_qual\s*function\s*$ret_val?(\w+)\s*\(/,
            [], ['is_func'], ['qualifier', 'return', 'name']
        ],
        func_end => [qr//,
            ['!is_func'], []
        ],
        class_start => [qr/^\s*class\s+(\w+)(\s+extends\s+(\w+))?/,
            ['is_class'], ['name', 'extends', 'base']
        ],
        class_end => [qr/^\s*endclass/,
            ['!is_class'], []
        ],
    };

    $self->{re}->{py} = {
        # Format is regex to match, flags to check, flags to set, captures
        func_start => [qr/^\s+def (\w+)\s*\(/,
            ['is_class'], ['is_func'], ['name']
        ],
        func_end => [qr//,
            ['is_func'], ['!is_func'], []
        ],
        class_start => [qr//,
            [], ['is_class'], ['name', 'base']
        ],
        class_end => [qr//,
            ['is_class'], ['!is_class'], []
        ],
    };
}

1;

#---------------------------------------------------------------------------
# MAIN
#---------------------------------------------------------------------------

package main;

my %opt;
GetOptions(
    # Standard arguments
    "d|debug"   => \$opt{debug},
    "f=s"       => \$opt{f},
    "help|?"    => \$opt{help},
    "man"       => \$opt{man},
    "o=s"       => \$opt{o},
    "q|quiet"   => \$opt{quiet},
    "v|verbose" => \$opt{verbose},

    # Custom arguments
    <+opt1+> => \$opt{<+val1+>},
    <+opt2+> => \$opt{<+val2+>},
);

pod2usage(1) if $opt{help};
pod2usage(-exitval => 0, -verbose => 2) if $opt{man};

my @files = @ARGV;

my $py_data = create_data();
my $sv_data = create_data();
my $P = Parser->new();

foreach my $f (@files) {
    _msg("Processing now file $f");
    process_file($f, $sv_data, $py_data);
}

#-----------------------------------------------------------------------------
# Internal helper functions (autogenerated)
#-----------------------------------------------------------------------------

sub process_file {
    my ($fname, $sv, $py) = @_;
    my $data = {
        sv => $sv,
        py => $py
    };
    open(my $IFILE, "<", $fname) or die $!;
    while (<$IFILE>) {
        my $line = $_;
        if ($P->func_start($line)) {

        }
        elsif ($P->func_end($line)) {

        }
        elsif ($P->class_start($line)) {

        }
        elsif ($P->class_end($line)) {

        }
    }
    close($IFILE);
}

sub create_data {
    my $href = {
        func => {}
    };
}

# For printing debug information
sub _debug {
    my ($msg) = @_;
    print "status.pl [DEBUG] $msg\n" if $opt{debug};
}

# For printing out messages if not quiet
sub _msg {
    my ($msg) = @_;
    print "status.pl $msg\n" unless $opt{quiet};
}

# For printing error information
sub _error {
    my ($msg) = @_;
    print STDERR "status.pl [ERROR]$msg\n";
}

__END__
=head1 NAME

=head1 SYNOPSIS

status.pl [options]

  Options:
    -d|debug    Turn on all debugging features.
    -f          Input file.
    -help       Print help message.
    -man        Bring up man-pages of the script.
    -o          Output file.
    -q|quiet    Run script in quiet mode (no std out).
    -v|verbose  Run script in verbose mode (more std out).

=head1 OPTIONS

=over 8

=item B<-d|debug>

Turns on all debugging features.

=item B<-f> <filename>

Name of the input file.

=item B<-help>

Prints help message.

=item B<-man>

Shows the man-pages.

=item B<-o> <filename>

Output file name.

=item B<-q|quiet>

Runs script in quiet mode.

=item B<-v|verbose>

Runs script in verbose mode.

=back

=head1 DESCRIPTION

Describe the script here.

=head1 AUTHOR

    Written by Tuomas Poikela, tuomas.sakari.poikela@gmail.com

=cut
